# Standard_ThirdWeek-

Q1
1. 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.
공통점	InputSystem을 사용해서 ActionMap과 Actions를 정의해서 입력처리를 합니다.
차이점
	입문 SendMessage를 통해 직접 함수를 string값으로 찾아서 입력값을 넣어줍니다.
	숙련 Event를 통해 함수를 직접 지정하여 비용이 줄었습니다.

2. `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.
	CharacteManager : GameObject간의 정보 통신
	Player : Player라는 gameObject 자식간의 정보 통신

3.  핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)
	Move -> wasd를 Vector2로 받아서 Vector3에서는 x,z 값으로 바꿔주고 y쪽은 rigidbody쪽 정보를 계속 노출시켜서 실제 점프 구현에 힘을 쓰게 하고 있습니다.
	CameraLook -> 유니티에서 제공하는 커서, 마우스에 관련된 클래스를 사용하여 마우스 델타값을 받아 사용자가 바라보는 시점에 맞게 vector2를 vecter3로 받고 회전값이니까 살짝 축에 놔둬주는 역할입니다.

	IsGrounded -> Ray는 원점과 방향을 정해서 쏘게 합니다. 플레이 기준 사각형으로 점을 찍고 아래로 방향을 줬습니다.
			이후 RayCast (특 : cast거리와, 오버로드옵션으로 레이어마스크 선정가능) -> 불값을 받아 냅니다. 이를 통해 점프를 한번만 할 수 있도록 컨트롤 합니다.

4.  `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.
	Move는 매 FixedUpdate 즉, 매 고정된 간격 연산하는 것이 중요해서 고정연산으로 합니다.
	LateUpdate는 Update 후에 오고, 프레임에 따라가는 것이 중요해서 프레임 후처리 작업에 나옵니다.




Q2
1. 별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.
	단일책임원칙으로 유저와 인터페이스하는 역할만 수행하는 것이 좋습니다. UI는 실시간으로 변하는 데이터를 노출 시켜줘야하는데, 연산까지 같이 하게 되면, 연산을 주기적으로 계산해야하다 어느순간 과부하가 오는 경우가 있습니다. 이를 방지하기 위해 연산은 비동기적으로 하고, 결과를 대기했다가 노출하는 것이 더 좋습니다. 그리고 연산방법이 바뀌면 연산스크립트만 수정하면되고, 노출하는 UI가 달라지면 UI만 손보면 되기에 유지보수에 용이 합니다.

2. 인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.
	인터페이스는 공통된 함수를 가지고 있어 다른 클래스에서 인터페이스로 접근하여 필요한 함수만 가져와서 매개변수로 사용할 수 있습니다.
	

3. 핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)
	캠프파이어는 컬렉션 내부의 함수를 주기적으로 노출하고 있습니다. 그리고 비동기적으로 트리거입장이벤트가 호출되면 컬렉션(리스트)에 닿은 물체의 정보를 저장하고 또 트리거퇴장이벤트가 호출되면 컬렉션에 제거하는 것으로 컬렉션은 계속 노출되고 내부 내용물이 트리거이벤트에 따라 추가되고 사라집니다.
	
	DamageIndicator는 캠프파이어에 있는 컬렉션에 대상이 추가되고 InvokeRepeating이 주기적으로 나옴에 따라 함수가 오출되고 이벤트를 받아서 행동하고 있습니다. 데미지를 받을 때마다 UI효과를 주는데 그 간격이 짧을 경우(코루틴이 아직 끝나지 않았을 때,) 코루틴을 멈추고 새로운 코루틴을 실행하는 것으로 메모리 누수에 대한 방어적 코드를 하고 있습니다.
